<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>PoP Priming Experiment (Digit WM)</title>
  <style>
    body { text-align:center; font-family:sans-serif; margin-top:30px; }
    canvas { background:#ccc; display:block; margin:10px auto; }
    button, input, select { padding:10px 20px; font-size:18px; margin:10px; }
    /* 数字列のフォント色は黒 */
    #digitDisplay { font-size:32px; font-weight:bold; margin:20px; color: black; }
  </style>
</head>
<body>
  <h2>PoP Priming Experiment (Digit WM)</h2>
  <canvas id="canvas" width="600" height="600"></canvas>

  <div id="startDiv">
    <button id="startBtn">Start Experiment</button>
  </div>

  <!-- 数字列提示用 -->
  <div id="digitDiv" style="display:none;">
    <div id="digitDisplay"></div>
  </div>

  <!-- 視覚探索回答 -->
  <div id="respDiv" style="display:none;">
    <p>Press F for Notch Up, J for Notch Down</p>
  </div>

  <!-- 数字列リコール用 -->
  <div id="recallDiv" style="display:none;">
    <input type="text" id="recallInput" maxlength="9" placeholder="Enter digits" />
    <select id="colorSelect">
      <option value="">Select Color</option>
      <option value="black">Black</option>
      <option value="red">Red</option>
      <option value="green">Green</option>
    </select>
    <button id="recallBtn">Submit</button>
  </div>

  <p id="status"></p>

<script>
// ==================== Google Apps Script 送信先 ====================
const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbxG_UikVlyzJxj_kFZV53337XGkwpcX62qf1-f5Qfi5gNv7paXurH6oJ6a43j4kqav1hA/exec';

// ==================== Canvas 設定 ====================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const centerX = canvas.width / 2;
const centerY = canvas.height / 2;

// ==================== 実験パラメータ ====================
const TOTAL_TRIALS = 150;        // 総試行数
let trialIdx = 0;                // 現在の試行 (0-based)
let memoryBuffer = null;         // 現在保持中の数字列 (文字列)
let memoryColor = null;          // 現在保持中の数字列の色 (black / red / green)
let memoryTrialCountdown = 0;    // 次のリコールまで探索試行を何回消費するか
let currentTrial = null;         // 現在の試行オブジェクト
let startTime = 0;               // RT 計測用タイムスタンプ
const subj = 'subj_' + Date.now(); // 被験者 ID

let fixedMemoryTrial = null;     // digit_encode→digit_recall 間で固定する試行オブジェクト
let prevColor = null;            // 直前のターゲット色
let prevCount = 0;               // 直前までの連続ターゲット色回数

// ==================== メモリ試行の4ブロック条件 ====================
// 各ブロックを 15 回ずつ、かつ 2 周 (合計 15*4*2 = 120試行)
const memoryConditions = [];
for (let repeat = 0; repeat < 2; repeat++) {
  // ブロック1：2桁 × 黒 (block = 1)
  for (let i = 0; i < 15; i++) {
    memoryConditions.push({ digitLength: 2, digitColorType: 'black', block: 1 });
  }
  // ブロック2：5桁 × 黒 (block = 2)
  for (let i = 0; i < 15; i++) {
    memoryConditions.push({ digitLength: 5, digitColorType: 'black', block: 2 });
  }
  // ブロック3：2桁 × カラー (block = 3)
  for (let i = 0; i < 15; i++) {
    memoryConditions.push({ digitLength: 2, digitColorType: 'color', block: 3 });
  }
  // ブロック4：5桁 × カラー (block = 4)
  for (let i = 0; i < 15; i++) {
    memoryConditions.push({ digitLength: 5, digitColorType: 'color', block: 4 });
  }
}

// ==================== 描画関数 ====================
/** 円環と注視点 (fixation cross) を描画 */
function drawAnnulusAndFixation(color) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.lineWidth = 20;
  ctx.strokeStyle = color;
  ctx.beginPath();
  ctx.arc(centerX, centerY, 200, 0, 2 * Math.PI);
  ctx.stroke();
  // 注視点 (白い十字)
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(centerX - 10, centerY);
  ctx.lineTo(centerX + 10, centerY);
  ctx.moveTo(centerX, centerY - 10);
  ctx.lineTo(centerX, centerY + 10);
  ctx.stroke();
}

/** ひし形 (diamond) 刺激を描画 */
function drawItem(x, y, size, color, notch) {
  const halfH = size / 2;
  const halfW = size * 0.4;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x, y - halfH);
  ctx.lineTo(x + halfW, y);
  ctx.lineTo(x, y + halfH);
  ctx.lineTo(x - halfW, y);
  ctx.closePath();
  ctx.fill();
  // ノッチ
  ctx.fillStyle = '#ccc';
  const cutHeight = halfH * 0.5;
  if (notch === 'up') {
    ctx.fillRect(x - halfW * 0.6, y - halfH, halfW * 1.2, cutHeight);
  } else {
    ctx.fillRect(x - halfW * 0.6, y + halfH - cutHeight, halfW * 1.2, cutHeight);
  }
}

/** 正三角形の頂点に対応する 3 つの座標を返す */
function getSymmetricPositions(radius = 100) {
  const angles = [0, 120, 240].map(deg => deg * Math.PI / 180);
  return angles.map(a => [centerX + radius * Math.cos(a), centerY + radius * Math.sin(a)]);
}

/** ランダムな数字列 (length 桁) を生成 */
function generateDigits(length) {
  return Array.from({ length }, () => Math.floor(Math.random() * 10)).join('');
}

/** ターゲット色連続回数に応じた反復確率を返す: 100 - 20 * sqrt(n) */
function getRepeatProbability(n) {
  return Math.max(0, 100 - 20 * Math.sqrt(n));
}

// ==================== 試行生成 ====================
/**
 * trialIdx に応じて試行情報を生成
 * - trialIdx < 30 => 視覚探索のみ (searchOnly)
 * - 全体の先頭 30 試行以外 => memoryConditions 配列から取り出し 
 */
function generateTrial() {
  if (trialIdx < 30) {
    // Controlled Phase: 30 回の純粋な視覚探索
    const repeatProb = getRepeatProbability(prevCount);
    const repeat = (Math.random() * 100 < repeatProb);
    const tCol = (repeat && prevColor) ? prevColor : (prevColor === 'red' ? 'green' : 'red');
    const dCol = (tCol === 'red') ? 'green' : 'red';
    if (tCol === prevColor) prevCount++;
    else prevCount = 1;
    prevColor = tCol;
    return {
      trial_number: trialIdx + 1,
      tCol, 
      dCol,
      isMemory: false,
      task: 'searchOnly',
      block: 0
    };
  } else {
    // Memory Phase: 120 試行
    const idx = trialIdx - 30;
    const cond = memoryConditions[idx];
    const isMemory = (memoryBuffer === null && memoryTrialCountdown === 0);
    const tCol = (Math.random() < 0.5) ? 'red' : 'green';
    const dCol = (tCol === 'red') ? 'green' : 'red';
    // ブロック条件から digitColor を設定 (黒 or ターゲット色)
    const digitColor = (cond.digitColorType === 'color') ? tCol : 'black';
    return {
      trial_number: trialIdx + 1,
      tCol,
      dCol,
      isMemory,
      digitLength: cond.digitLength,
      digitColor,
      block: cond.block
    };
  }
}

// ==================== 試行実行 ====================
function runTrial() {
  let tr;
  // リコール直後に次の記憶試行が続くときの処理
  if (memoryBuffer !== null && memoryTrialCountdown === 0) {
    tr = { ...fixedMemoryTrial };
  } else {
    tr = generateTrial();
    if (tr.isMemory) {
      fixedMemoryTrial = tr;
    }
  }
  currentTrial = tr;

  // --- Memory Encode フェーズ ---
  if (tr.isMemory) {
    memoryBuffer = generateDigits(tr.digitLength);
    memoryColor = tr.digitColor;
    memoryTrialCountdown = 3;

    // 数字列を表示
    const digitDiv = document.getElementById('digitDiv');
    const digitDisplay = document.getElementById('digitDisplay');
    digitDisplay.innerText = memoryBuffer;
    digitDisplay.style.color = memoryColor;
    digitDiv.style.display = 'block';
    drawAnnulusAndFixation('white');

    // データ送信 (digit_encode)
    saveTrial({
      ...tr,
      task: 'digit_encode',
      digits: memoryBuffer,
      digit_color: memoryColor,
      block: tr.block
    });

    // 5秒後に数字列非表示 → nextTrial
    setTimeout(() => {
      digitDiv.style.display = 'none';
      nextTrial();
    }, 5000);

  // --- Memory Recall フェーズ ---
  } else if (memoryBuffer !== null && memoryTrialCountdown === 0) {
    drawAnnulusAndFixation('white');
    document.getElementById('recallDiv').style.display = 'block';
    startTime = Date.now();

    currentTrial = {
      ...tr,
      task: 'digit_recall',
      correct_digits: memoryBuffer,
      correct_color: memoryColor,
      block: tr.block
    };

  // --- Search Only / Search フェーズ ---
  } else {
    if (memoryTrialCountdown > 0) memoryTrialCountdown--;
    drawAnnulusAndFixation('black');

    // 1000ms 後に刺激提示
    setTimeout(() => {
      const positions = getSymmetricPositions();
      const targetIndex = Math.floor(Math.random() * 3);
      const colors = [tr.dCol, tr.dCol, tr.dCol];
      colors[targetIndex] = tr.tCol;

      const notches = ['down', 'down', 'down'];
      notches[targetIndex] = (Math.random() < 0.5) ? 'up' : 'down';
      const correct = notches[targetIndex];

      positions.forEach((pos, i) => {
        drawItem(pos[0], pos[1], 80, colors[i], notches[i]);
      });

      document.getElementById('respDiv').style.display = 'block';
      startTime = Date.now();
      currentTrial = {
        ...tr,
        task: (tr.task === 'searchOnly') ? 'searchOnly' : 'search',
        colors,
        notches,
        correct,
        block: tr.block
      };
    }, 1000);
  }
}

// ==================== 応答処理 ====================
/** Search / SearchOnly のキー応答 (F=up, J=down) */
function handleSearchResp(ans) {
  document.getElementById('respDiv').style.display = 'none';
  const rt = Date.now() - startTime;
  const correct = (ans === currentTrial.correct);

  saveTrial({
    ...currentTrial,
    response: ans,
    rt_ms: rt,
    is_correct: correct,
    block: currentTrial.block
  });
  nextTrial();
}

/** Memory Recall の Submit */
function handleRecall() {
  const ans = document.getElementById('recallInput').value.trim();
  const color = document.getElementById('colorSelect').value;
  document.getElementById('recallDiv').style.display = 'none';
  const rt = Date.now() - startTime;
  const correct = (ans === currentTrial.correct_digits && color === currentTrial.correct_color);

  saveTrial({
    ...currentTrial,
    response_digits: ans,
    response_color: color,
    rt_ms: rt,
    is_correct: correct,
    block: currentTrial.block,
    correct_digits: currentTrial.correct_digits
  });

  memoryBuffer = null;
  memoryColor = null;
  fixedMemoryTrial = null;
  document.getElementById('recallInput').value = '';
  document.getElementById('colorSelect').value = '';
  nextTrial();
}

// ==================== データ送信・試行制御 ====================
function saveTrial(data) {
  fetch(WEB_APP_URL, {
    method: 'POST',
    body: JSON.stringify({ subject_id: subj, ...data })
  }).catch(console.error);
}

function nextTrial() {
  trialIdx++;
  if (trialIdx < TOTAL_TRIALS) {
    runTrial();
  } else {
    document.getElementById('status').innerText = 'Experiment complete';
  }
}

// ==================== イベントリスナ ====================
document.addEventListener('keydown', e => {
  if (document.getElementById('respDiv').style.display !== 'none') {
    if (e.key === 'f') handleSearchResp('up');
    else if (e.key === 'j') handleSearchResp('down');
  }
});

document.getElementById('startBtn').addEventListener('click', () => {
  document.getElementById('startDiv').style.display = 'none';
  runTrial();
});
document.getElementById('recallBtn').addEventListener('click', handleRecall);
</script>
</body>
</html>
