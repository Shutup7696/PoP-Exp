<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>PoP Priming Experiment (Digit WM)</title>
  <style>
    body { text-align:center; font-family:sans-serif; margin-top:30px; }
    canvas { background:#ccc; display:block; margin:10px auto; }
    button, input, select { padding:10px 20px; font-size:18px; margin:10px; }
    #digitDisplay { font-size:32px; font-weight:bold; margin:20px; }
  </style>
</head>
<body>
  <h2>PoP Priming Experiment (Digit WM)</h2>
  <canvas id="canvas" width="600" height="600"></canvas>

  <div id="startDiv">
    <button id="startBtn">Start Experiment</button>
  </div>

  <!-- 数字列提示用 -->
  <div id="digitDiv" style="display:none;">
    <div id="digitDisplay"></div>
  </div>

  <!-- 視覚探索応答案内 -->
  <div id="respDiv" style="display:none;">
    <p>Press F for Notch Up, J for Notch Down</p>
  </div>

  <!-- 数字列リコール用 -->
  <div id="recallDiv" style="display:none;">
    <input type="text" id="recallInput" maxlength="5" placeholder="Enter digits" />
    <select id="colorSelect">
      <option value="">Select Color</option>
      <option value="white">White</option>
      <option value="red">Red</option>
      <option value="green">Green</option>
    </select>
    <button id="recallBtn">Submit</button>
  </div>

  <p id="status"></p>

<script>
const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbxG_UikVlyzJxj_kFZV53337XGkwpcX62qf1-f5Qfi5gNv7paXurH6oJ6a43j4kqav1hA/exec';

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const centerX = canvas.width / 2;
const centerY = canvas.height / 2;

const TOTAL_TRIALS = 40;
let trialIdx = 0;
let memoryBuffer = null;
let memoryColor = null;
let memoryTrialCountdown = 0;
let currentTrial = null;
let startTime = 0;
let subj = 'subj_' + Date.now();

/** 円環＋注視点を描画する */
function drawAnnulusAndFixation(color) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.lineWidth = 20;
  ctx.strokeStyle = color;
  ctx.beginPath();
  ctx.arc(centerX, centerY, 200, 0, 2 * Math.PI);
  ctx.stroke();
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(centerX - 10, centerY);
  ctx.lineTo(centerX + 10, centerY);
  ctx.moveTo(centerX, centerY - 10);
  ctx.lineTo(centerX, centerY + 10);
  ctx.stroke();
}

/** ひし形を描画する */
function drawItem(x, y, size, color, notch) {
  const halfH = size / 2;
  const halfW = size * 0.4;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x, y - halfH);
  ctx.lineTo(x + halfW, y);
  ctx.lineTo(x, y + halfH);
  ctx.lineTo(x - halfW, y);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = '#ccc';
  const cutHeight = halfH * 0.5;
  if (notch === 'up') {
    ctx.fillRect(x - halfW * 0.6, y - halfH, halfW * 1.2, cutHeight);
  } else {
    ctx.fillRect(x - halfW * 0.6, y + halfH - cutHeight, halfW * 1.2, cutHeight);
  }
}

/** 3つのひし形を等間隔に並べる中心座標を取得 */
function getSymmetricPositions(radius = 100) {
  const angles = [0, 120, 240].map(deg => deg * Math.PI / 180);
  return angles.map(a => [centerX + radius * Math.cos(a), centerY + radius * Math.sin(a)]);
}

/** 長さ length のランダム数字列を生成 */
function generateDigits(length) {
  return Array.from({ length }, () => Math.floor(Math.random() * 10)).join('');
}

/**
 * 試行内容を生成
 * - isMemory: メモリ試行かどうか
 * - tCol, dCol: ターゲット色・ディストラクタ色
 * - digitLength: 2 or 5
 * - digitColor: 'white' or tCol/dCol
 * - block: 1-4 を割り振る
 */
function generateTrial() {
  const isMemory = (memoryBuffer === null && Math.random() < 0.25 && memoryTrialCountdown === 0);
  const tCol = Math.random() < 0.5 ? 'red' : 'green';
  const dCol = (tCol === 'red') ? 'green' : 'red';

  // 数字列の長さと色をランダムに決定
  const digitLength = (Math.random() < 0.5) ? 2 : 5;
  const digitColor = (Math.random() < 0.5) ? 'white' : tCol;

  // block の決定：
  // 2桁白 → block 1
  // 5桁白 → block 2
  // 2桁カラー → block 3
  // 5桁カラー → block 4
  let block;
  if (digitLength === 2 && digitColor === 'white') block = 1;
  else if (digitLength === 5 && digitColor === 'white') block = 2;
  else if (digitLength === 2 && digitColor !== 'white') block = 3;
  else block = 4;

  return {
    trial_number: trialIdx + 1,
    isMemory,
    tCol,
    dCol,
    digitLength,
    digitColor,
    block
  };
}

/** 1試行を実行 */
function runTrial() {
  const tr = generateTrial();
  currentTrial = { ...tr };

  if (tr.isMemory) {
    // --- 数字列提示フェーズ（白い円環） ---
    memoryBuffer = generateDigits(tr.digitLength);
    memoryColor = tr.digitColor;
    memoryTrialCountdown = 3;

    drawAnnulusAndFixation('white');
    document.getElementById('digitDisplay').style.color = memoryColor;
    document.getElementById('digitDisplay').innerText = memoryBuffer;
    document.getElementById('digitDiv').style.display = 'block';

    // データ保存（encode）
    saveTrial({
      ...tr,
      task: 'digit_encode',
      digits: memoryBuffer,
      digit_color: memoryColor
    });

    // 5秒後に非表示＆次試行
    setTimeout(() => {
      document.getElementById('digitDiv').style.display = 'none';
      nextTrial();
    }, 5000);

  } else if (memoryBuffer !== null && memoryTrialCountdown === 0) {
    // --- リコールフェーズ（白い円環） ---
    drawAnnulusAndFixation('white');
    document.getElementById('recallDiv').style.display = 'block';
    startTime = Date.now();
    currentTrial.task = 'digit_recall';
    currentTrial.correct_digits = memoryBuffer;
    currentTrial.correct_color = memoryColor;

  } else {
    // --- 視覚探索フェーズ（黒い円環 → 1000ms 後にひし形描画） ---
    if (memoryTrialCountdown > 0) memoryTrialCountdown--;

    drawAnnulusAndFixation('black');

    setTimeout(() => {
      const positions = getSymmetricPositions();
      const targetIndex = Math.floor(Math.random() * 3);
      const colors = [tr.dCol, tr.dCol, tr.dCol];
      colors[targetIndex] = tr.tCol;

      const notches = ['down', 'down', 'down'];
      notches[targetIndex] = Math.random() < 0.5 ? 'up' : 'down';
      const correct = notches[targetIndex];

      positions.forEach((pos, i) => {
        drawItem(pos[0], pos[1], 80, colors[i], notches[i]);
      });

      document.getElementById('respDiv').style.display = 'block';
      startTime = Date.now();
      currentTrial.task = 'search';
      currentTrial.colors = colors;
      currentTrial.notches = notches;
      currentTrial.correct = correct;
    }, 1000);
  }
}

/** 探索課題のキー応答 */
function handleSearchResp(ans) {
  document.getElementById('respDiv').style.display = 'none';
  const rt = Date.now() - startTime;
  const correct = (ans === currentTrial.correct);

  saveTrial({
    ...currentTrial,
    response: ans,
    rt_ms: rt,
    is_correct: correct
  });
  nextTrial();
}

/** 数字リコールの回答処理 */
function handleRecall() {
  const ansDigits = document.getElementById('recallInput').value.trim();
  const ansColor = document.getElementById('colorSelect').value;
  document.getElementById('recallDiv').style.display = 'none';
  const rt = Date.now() - startTime;
  const correct = (ansDigits === currentTrial.correct_digits && ansColor === currentTrial.correct_color);

  saveTrial({
    ...currentTrial,
    response_digits: ansDigits,
    response_color: ansColor,
    rt_ms: rt,
    is_correct: correct
  });

  memoryBuffer = null;
  memoryColor = null;
  document.getElementById('recallInput').value = '';
  document.getElementById('colorSelect').value = '';
  nextTrial();
}

/** Google Apps Script にデータを送信 */
function saveTrial(data) {
  fetch(WEB_APP_URL, {
    method: 'POST',
    body: JSON.stringify({ subject_id: subj, ...data })
  }).catch(console.error);
}

/** 次の試行へ */
function nextTrial() {
  trialIdx++;
  if (trialIdx < TOTAL_TRIALS) {
    runTrial();
  } else {
    document.getElementById('status').innerText = 'Experiment complete';
  }
}

// イベントリスナ設定
document.getElementById('startBtn').addEventListener('click', () => {
  document.getElementById('startDiv').style.display = 'none';
  runTrial();
});

// キー応答 (探索課題中のみ)
document.addEventListener('keydown', e => {
  if (document.getElementById('respDiv').style.display !== 'none') {
    if (e.key.toLowerCase() === 'f') handleSearchResp('up');
    else if (e.key.toLowerCase() === 'j') handleSearchResp('down');
  }
});

// リコール回答のSubmit
document.getElementById('recallBtn').addEventListener('click', handleRecall);
</script>
</body>
</html>
